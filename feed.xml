<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="//github-yet.orlicz.top/jekyll-theme-yat/feed.xml" rel="self" type="application/atom+xml" /><link href="//github-yet.orlicz.top/jekyll-theme-yat/" rel="alternate" type="text/html" /><updated>2025-01-22T10:16:20+00:00</updated><id>//github-yet.orlicz.top/jekyll-theme-yat/feed.xml</id><title type="html">Orlicz Space</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><author><name>Orlicz</name></author><entry><title type="html">Wc</title><link href="//github-yet.orlicz.top/jekyll-theme-yat/2025/01/21/wc.html" rel="alternate" type="text/html" title="Wc" /><published>2025-01-21T00:00:00+00:00</published><updated>2025-01-21T00:00:00+00:00</updated><id>//github-yet.orlicz.top/jekyll-theme-yat/2025/01/21/wc</id><content type="html" xml:base="//github-yet.orlicz.top/jekyll-theme-yat/2025/01/21/wc.html"><![CDATA[<p>我在WC，除了听课外，有以下几个收获：</p>

<ul>
  <li>
    <p>我和什么先生探讨了人生的意义。读者可能不知道什么是什么先生，其定义类似于山水先生。</p>

    <p>未知生，焉知死。我问，如果我对于人的定义，人思考的能力的大小，人智慧的本质 都是不能理解的，我岂可以理解人的意义？</p>

    <p>什么先生告诉我不是这样的。我也认同这个观点。在没有对 实数，集合，函数，几何，其中任何一个的定义完善之前，人们就已经可以做到远远高深的事情了。需要从头到尾认识一个东西，并不是正确的方法。</p>

    <p>什么先生教我不要思考通用的人生的意义，要思考具体的，有条件的，分情况的。他说古今很多人都做过这里的工作，造论子没有作用。</p>

    <p>我听说一个人说正义就是“一个人，在他的国家，做他应作的事”</p>

    <p><img src="/imgs/2025-01-21/cYKoOs92vgwcn7Va.png" alt="输入图片说明" />
一方面我没有必要按照baidubaike作为字典；另一方面baike里面的东西大多不是其原创，而是反映整体的观点</p>

    <p>我问你们，人生的意义是什么，社会的本质是什么，人活着是为了什么，生命的本质是什么，正义是什么。</p>

    <p>我觉得qjm应当不反对我在这里声称他和我一样认同一个人无论活成什么样子，都要将就着过。很多人不清楚人生的意义是什么，其活着的原因是其不想不活着，归根究底，就是认同其生命的可贵。</p>

    <p>我在之前曾经做过文章，内容是庄子秋水。我觉得那篇文章说的是大家的平等。</p>

    <blockquote>
      <p>计四海之在天地之间也，不似礨空之在大泽乎？计中国之在海内，不似稊米之在大仓乎？号物之数谓之万，人处一焉；人卒九州，谷食之所生，舟车之所通，人处一焉。此其比万物也，不似豪末之在于马体乎？五帝之所连，三王之所争，仁人之所忧，任士之所劳，尽此矣！伯夷辞之以为名，仲尼语之以为博。此其自多也，不似尔向之自多于水乎？</p>
    </blockquote>

    <p>则里面有一句话说的不对。中国之在海内，的确不似稊米之在大仓。</p>

    <p>也有的话说的对。河伯曰：“何谓天？何谓人？”</p>

    <p>我不能理解，为什么有人声称“贩夫走卒”是秋水里的，白白让我引用了这句话。但是好在我发现秋水确实很高。</p>

    <blockquote>
      <p>以下内容来自https://baike.baidu.com/item/%E5%B4%94%E8%8B%B1%E6%9D%B0/73129</p>
    </blockquote>

    <blockquote>
      <p>贩夫走卒、引车卖浆，是古已有之的正当职业。我的当事人来到城市，被生活所迫，从事这样一份卑微贫贱的工作，生活窘困，收入微薄。但他始终善良纯朴，无论这个社会怎样伤害他，他没有偷盗没有抢劫，没有以伤害他人的方式生存。我在法庭上庄严地向各位发问，当一个人赖以谋生的饭碗被打碎，被逼上走投无路的绝境，将心比心，你们会不会比我的当事人更加冷静和忍耐？</p>
    </blockquote>

    <blockquote>
      <p>我的当事人崔英杰，一直是孝顺的孩子，守法的良民，在部队是优秀的军人。他和他的战友们一直在为我们的国家默默付出；当他脱下军装走出军营，未被安置工作时也没有抱怨过这个社会对他的不公。这个国家像崔英杰一样在默默讨生活的复员军人何止千万，他们同样在关注崔英杰的命运，关注着本案的结果。</p>
    </blockquote>

    <blockquote>
      <p>法谚有云：立良法于天下者，则天下治。尊敬的法官，尊敬的检察官：我们的法律、我们的城市管理制度究竟是要使我们的公民更幸福还是要使他们更困苦？我们作为法律人的使命是要使这个社会更和谐还是要使它更惨烈？</p>
    </blockquote>

    <p>这就叫天才。我很受到震撼。</p>
  </li>
</ul>

<hr />
<p>归根究底，事从 众而强者，我们终于还是要用朴素的方式呼应人朴素的内心。
  行私走卒，引车灌浆；钉头磷磷，瓦缝参差；汗滴下土，带月荷锄。山水先生问我们，我们在打着CF比赛，领着codeton；有人则在吃不饱饭，冻死于寒风。</p>

<p>我问你们，这是为什么。大家不妨想想是不是只是因为没有到你头上。</p>

<p>我对cxm和cfz说，我们高二没有au之后，扫大街的时候。会后悔现在闲暇的时光，后悔现在写的这些无聊博客；回忆我们听别人唱歌，参加文艺汇演，和别人说话，会不会感到真正的沧桑？</p>

<ul>
  <li>第二个收获是我的舍友教给我的。由于这个舍友可能会成为大人物，我提及一下其名字：linear。他教我如果宿舍厕所在使用水冲走排遗物困难时可以使用paper coving method，翻译过来就是放上几张纸增大受力面积。读者不要觉得其不够高雅；但很多人都从本段文章中学到了这个行之有效的方法，人间万事，不学不会，不做不知，归根究底，并无不妥。</li>
  <li>第三个收获是我开始学习卡常和agc了。</li>
</ul>

<p>谢谢各位领导。大家辛苦了。
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTA1MjY4ODkxMiwzOTE4NTU1MzUsNjIzMz
kzNTAxXX0=
--></p>]]></content><author><name>Orlicz</name></author><summary type="html"><![CDATA[我在WC，除了听课外，有以下几个收获：]]></summary></entry><entry><title type="html">Zkw</title><link href="//github-yet.orlicz.top/jekyll-theme-yat/2024/12/30/zkw.html" rel="alternate" type="text/html" title="Zkw" /><published>2024-12-30T00:00:00+00:00</published><updated>2024-12-30T00:00:00+00:00</updated><id>//github-yet.orlicz.top/jekyll-theme-yat/2024/12/30/zkw</id><content type="html" xml:base="//github-yet.orlicz.top/jekyll-theme-yat/2024/12/30/zkw.html"><![CDATA[<p>zkw 线段树并没有实际的意义，这远远不如seg beats困难和有区分度。但是无所谓</p>

<p>以下是我的zkw</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span><span class="n">T</span> <span class="n">e</span><span class="p">,</span><span class="k">class</span> <span class="nc">F</span><span class="o">=</span><span class="n">T</span><span class="p">(</span><span class="o">&amp;&amp;</span><span class="p">)(</span><span class="n">T</span><span class="p">,</span><span class="n">T</span><span class="p">)&gt;</span>
<span class="k">struct</span> <span class="nc">zkw</span><span class="p">{</span>
	<span class="n">F</span> <span class="n">f</span><span class="p">;</span><span class="n">T</span> <span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="o">&lt;&lt;</span><span class="n">__lg</span><span class="p">(</span><span class="n">maxn</span><span class="p">)];</span><span class="kt">int</span> <span class="n">m</span><span class="p">;</span>
	<span class="n">zkw</span><span class="p">(</span><span class="n">F</span> <span class="k">const</span><span class="o">&amp;</span><span class="n">f</span><span class="o">=</span><span class="n">F</span><span class="p">())</span><span class="o">:</span><span class="n">f</span><span class="p">(</span><span class="n">f</span><span class="p">){}</span>
	<span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span><span class="n">m</span><span class="o">=</span><span class="mi">2</span><span class="o">&lt;&lt;</span><span class="n">__lg</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="n">fill</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="p">(</span><span class="n">m</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">),</span><span class="n">e</span><span class="p">);}</span>
	<span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="n">A</span><span class="p">,</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
		<span class="n">m</span><span class="o">=</span><span class="mi">2</span><span class="o">&lt;&lt;</span><span class="n">__lg</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">A</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">));</span>
		<span class="n">fill</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">m</span><span class="o">+</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="p">(</span><span class="n">m</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">),</span><span class="n">e</span><span class="p">);</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">m</span><span class="p">;</span><span class="o">--</span><span class="n">i</span><span class="p">;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="o">|</span><span class="mi">1</span><span class="p">]));</span>
	<span class="p">}</span>
	<span class="kt">void</span> <span class="nf">upd</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">,</span><span class="n">T</span> <span class="n">x</span><span class="p">){</span><span class="k">for</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">p</span><span class="o">|=</span><span class="n">m</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">;</span><span class="n">p</span><span class="o">&gt;&gt;=</span><span class="mi">1</span><span class="p">;</span><span class="n">a</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">=</span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">p</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="n">p</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="o">|</span><span class="mi">1</span><span class="p">]));}</span>
	<span class="n">T</span> <span class="nf">qry</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="kt">int</span> <span class="n">r</span><span class="p">){</span>
		<span class="n">T</span> <span class="n">res</span><span class="o">=</span><span class="n">e</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span><span class="n">l</span><span class="o">+=</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="o">+=</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="n">l</span><span class="o">^</span><span class="n">r</span><span class="o">^</span><span class="mi">1</span><span class="p">;</span><span class="n">l</span><span class="o">&gt;&gt;=</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="o">&gt;&gt;=</span><span class="mi">1</span><span class="p">){</span>
			<span class="k">if</span><span class="p">(</span><span class="o">~</span><span class="n">l</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span><span class="n">res</span><span class="o">=</span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">l</span><span class="o">^</span><span class="mi">1</span><span class="p">],</span><span class="n">res</span><span class="p">);</span>
			<span class="k">if</span><span class="p">(</span><span class="n">r</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span><span class="n">res</span><span class="o">=</span><span class="n">f</span><span class="p">(</span><span class="n">res</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="n">r</span><span class="o">^</span><span class="mi">1</span><span class="p">]);</span>
		<span class="p">}</span><span class="k">return</span> <span class="n">res</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>
<!--stackedit_data:
eyJoaXN0b3J5IjpbNzQxMDM1OTA4XX0=
-->]]></content><author><name>Orlicz</name></author><summary type="html"><![CDATA[zkw 线段树并没有实际的意义，这远远不如seg beats困难和有区分度。但是无所谓]]></summary></entry><entry><title type="html">More Trying</title><link href="//github-yet.orlicz.top/jekyll-theme-yat/2024/12/29/more-trying.html" rel="alternate" type="text/html" title="More Trying" /><published>2024-12-29T00:00:00+00:00</published><updated>2024-12-29T00:00:00+00:00</updated><id>//github-yet.orlicz.top/jekyll-theme-yat/2024/12/29/more-trying</id><content type="html" xml:base="//github-yet.orlicz.top/jekyll-theme-yat/2024/12/29/more-trying.html"><![CDATA[<p>我们一定要多尝试，山水先生曾经说过</p>

<blockquote>
  <h2 id="要多试试试的多了才知道什么是自己喜欢的">要多试试。试的多了，才知道什么是自己喜欢的</h2>
</blockquote>

<p>古代有一本书，叫做 《The Change》 ，翻译成现代汉语就是《易经》，意思就是要多尝试，多变化。</p>

<p>有一个古人说过“多言数穷，不如守中。”这个称之为老子的古人说的并非全对，意思说，反正现在古诗文网的翻译是很高超的，指的是不要折腾，要少。</p>

<p>额，总之做题的时候一定多思考，</p>

<p>直觉固然重要，但是也要多尝试。把问题想得广泛，转化得弱一些也是可以的。比如，想到将一个序列问题转化成平面的矩形问题。这固然可能会导致一些hard，比如 increasing mex</p>

<p>就是说，给定一个muti集合，每次可以将相同两数中的一个增大或减少，问你如何不泪垂，给定一个序列，一些询问是每个区间做这个操作，可以实现的最大mex。</p>

<p>这个问题这样做，考虑枚举mex，相当于 &lt;=mex 的数的个数 超过mex。</p>

<p>这变成了平面减法，问平面max。这个做不了。可以kdt，</p>

<p>考虑一个新的思想。<strong>一个长的区间答案一定更大</strong>，所以如果存在包含关系，就将被包含的延迟加入。这样就是一个平衡树或线段树的问题了（我之前分析的时候，差不多感知出来这个了，但是我失败了，因为我觉得，一方面大的区间更容易减少，另一方面大的区间反而答案一定更大，这台奇怪了。其实本来就应该继续尝试的。但是谁的思考链这么长呢？）</p>

<p>然后还有一些问题，看似是求合法区间个数，但是实则会发现合法区间完全没有什么方法，要是扫描线之后问题形式无比困难。唯一正确的方法是，正难则反。大体上就是线段树求区间历史最小值恰好是k的个数，这是什么啊！！！正确的做法是对每个不合法的区间容斥。总之还是听有意思的。</p>

<p>多尝试，培养直觉。
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEyNDgwNTQxNThdfQ==
--></p>]]></content><author><name>Orlicz</name></author><summary type="html"><![CDATA[我们一定要多尝试，山水先生曾经说过]]></summary></entry><entry><title type="html">Eating</title><link href="//github-yet.orlicz.top/jekyll-theme-yat/2024/12/22/eating.html" rel="alternate" type="text/html" title="Eating" /><published>2024-12-22T00:00:00+00:00</published><updated>2024-12-22T00:00:00+00:00</updated><id>//github-yet.orlicz.top/jekyll-theme-yat/2024/12/22/eating</id><content type="html" xml:base="//github-yet.orlicz.top/jekyll-theme-yat/2024/12/22/eating.html"><![CDATA[<h2 id="什么是生命">什么是生命</h2>

<p>这是一个标题。</p>

<!--stackedit_data:
eyJoaXN0b3J5IjpbNzYyMzA3MDA0XX0=
-->]]></content><author><name>Orlicz</name></author><summary type="html"><![CDATA[什么是生命]]></summary></entry><entry><title type="html">Fast Mod</title><link href="//github-yet.orlicz.top/jekyll-theme-yat/2024/12/22/fast-mod.html" rel="alternate" type="text/html" title="Fast Mod" /><published>2024-12-22T00:00:00+00:00</published><updated>2024-12-22T00:00:00+00:00</updated><id>//github-yet.orlicz.top/jekyll-theme-yat/2024/12/22/fast-mod</id><content type="html" xml:base="//github-yet.orlicz.top/jekyll-theme-yat/2024/12/22/fast-mod.html"><![CDATA[<h3 id="快速取模数">快速取模数</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">using</span> <span class="n">u32</span><span class="o">=</span><span class="kt">uint32_t</span><span class="p">;</span><span class="k">using</span> <span class="n">u64</span><span class="o">=</span><span class="kt">uint64_t</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">Barrett</span><span class="p">{</span>
	<span class="n">u64</span> <span class="n">ir</span><span class="p">,</span><span class="n">m</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">init</span><span class="p">(</span><span class="n">u32</span> <span class="n">m_</span><span class="p">){</span><span class="n">ir</span><span class="o">=</span><span class="p">((</span><span class="n">__int128</span><span class="p">)</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">64</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="n">m_</span><span class="p">);}</span>
	<span class="kr">inline</span> <span class="n">u64</span> <span class="k">operator</span><span class="p">()(</span><span class="n">u64</span> <span class="n">x</span><span class="p">)</span><span class="k">const</span><span class="p">{</span><span class="k">return</span> <span class="n">x</span><span class="o">-</span><span class="p">((</span><span class="n">__int128</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">ir</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">64</span><span class="p">)</span><span class="o">*</span><span class="n">m</span><span class="p">;}</span>
	<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span><span class="kr">inline</span> <span class="k">operator</span> <span class="n">T</span><span class="p">()</span><span class="k">const</span><span class="p">{</span><span class="k">return</span> <span class="n">m</span><span class="p">;}</span>
<span class="p">}</span><span class="n">mod</span><span class="p">;</span>
<span class="kr">inline</span> <span class="n">u64</span> <span class="k">operator</span><span class="o">%</span><span class="p">(</span><span class="n">u64</span> <span class="n">x</span><span class="p">,</span><span class="n">Barrett</span> <span class="n">mod</span><span class="p">){</span><span class="k">return</span> <span class="n">mod</span><span class="p">(</span><span class="n">x</span><span class="p">);}</span>
<span class="kr">inline</span> <span class="n">u64</span><span class="o">&amp;</span><span class="k">operator</span><span class="o">%=</span><span class="p">(</span><span class="n">u64</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span><span class="n">Barrett</span> <span class="n">mod</span><span class="p">){</span><span class="k">return</span> <span class="n">x</span><span class="o">=</span><span class="n">mod</span><span class="p">(</span><span class="n">x</span><span class="p">);}</span>
<span class="k">struct</span> <span class="nc">Montgomery</span><span class="p">{</span>
	<span class="n">u32</span> <span class="n">m</span><span class="p">,</span><span class="n">ir</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">u32</span> <span class="n">inv_m</span><span class="p">(</span><span class="n">u32</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">5</span><span class="p">;</span><span class="n">i</span><span class="o">--</span><span class="p">;)</span><span class="n">x</span><span class="o">*=</span><span class="mi">2</span><span class="o">-</span><span class="n">x</span><span class="o">*</span><span class="n">m</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">x</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="n">u32</span> <span class="n">m_</span><span class="p">){</span><span class="n">m</span><span class="o">=</span><span class="n">m_</span><span class="p">,</span><span class="n">ir</span><span class="o">=-</span><span class="n">inv_m</span><span class="p">(</span><span class="n">m</span><span class="p">),</span><span class="n">mod</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">m_</span><span class="p">);}</span>
	<span class="n">u32</span> <span class="nf">tran</span><span class="p">(</span><span class="n">u32</span> <span class="n">a</span><span class="p">)</span><span class="k">const</span><span class="p">{</span><span class="k">return</span> <span class="n">mod</span><span class="p">(</span><span class="n">u64</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">32</span><span class="p">);}</span>
	<span class="n">u32</span> <span class="nf">val</span><span class="p">(</span><span class="n">u32</span> <span class="n">a</span><span class="p">)</span><span class="k">const</span><span class="p">{</span><span class="k">return</span> <span class="n">redc_m</span><span class="p">(</span><span class="n">redc</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">-</span><span class="n">m</span><span class="p">);}</span>
	<span class="n">u32</span> <span class="nf">add</span><span class="p">(</span><span class="n">u32</span> <span class="n">a</span><span class="p">,</span> <span class="n">u32</span> <span class="n">b</span><span class="p">)</span><span class="k">const</span><span class="p">{</span><span class="k">return</span> <span class="n">redc_m2</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">-</span><span class="n">m</span><span class="o">*</span><span class="mi">2</span><span class="p">);}</span>
	<span class="n">u32</span> <span class="nf">sub</span><span class="p">(</span><span class="n">u32</span> <span class="n">a</span><span class="p">,</span> <span class="n">u32</span> <span class="n">b</span><span class="p">)</span><span class="k">const</span><span class="p">{</span><span class="k">return</span> <span class="n">redc_m2</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">b</span><span class="p">);}</span>
	<span class="n">u32</span> <span class="n">redc_m</span><span class="p">(</span><span class="n">u32</span> <span class="n">a</span><span class="p">)</span><span class="k">const</span><span class="p">{</span><span class="k">return</span> <span class="n">a</span><span class="o">&gt;&gt;</span><span class="mi">31</span><span class="o">?</span><span class="n">a</span><span class="o">+</span><span class="n">m</span><span class="o">:</span><span class="n">a</span><span class="p">;}</span>
	<span class="n">u32</span> <span class="n">redc_m2</span><span class="p">(</span><span class="n">u32</span> <span class="n">a</span><span class="p">)</span><span class="k">const</span><span class="p">{</span><span class="k">return</span> <span class="n">a</span><span class="o">&gt;&gt;</span><span class="mi">31</span><span class="o">?</span><span class="n">a</span><span class="o">+</span><span class="n">m</span><span class="o">*</span><span class="mi">2</span><span class="o">:</span><span class="n">a</span><span class="p">;}</span>
	<span class="n">u32</span> <span class="n">redc</span><span class="p">(</span><span class="n">u64</span> <span class="n">a</span><span class="p">)</span><span class="k">const</span><span class="p">{</span><span class="k">return</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">u64</span><span class="p">(</span><span class="n">u32</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">ir</span><span class="p">)</span><span class="o">*</span><span class="n">m</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">32</span><span class="p">;}</span>
	<span class="n">u32</span> <span class="nf">mul</span><span class="p">(</span><span class="n">u32</span> <span class="n">a</span><span class="p">,</span><span class="n">u32</span> <span class="n">b</span><span class="p">)</span><span class="k">const</span><span class="p">{</span><span class="k">return</span> <span class="n">redc</span><span class="p">(</span><span class="n">u64</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">b</span><span class="p">);}</span>
<span class="p">}</span><span class="n">mtg</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">mint</span><span class="p">{</span>
	<span class="n">u32</span> <span class="n">z</span><span class="p">;</span>
	<span class="n">mint</span><span class="p">()</span><span class="o">=</span><span class="k">default</span><span class="p">;</span>
	<span class="n">mint</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">z</span><span class="p">(</span><span class="n">mtg</span><span class="p">.</span><span class="n">tran</span><span class="p">(</span><span class="n">x</span><span class="p">)){}</span>
	<span class="n">mint</span><span class="p">(</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="n">z</span><span class="p">)</span><span class="o">:</span><span class="n">z</span><span class="p">(</span><span class="o">*</span><span class="n">z</span><span class="p">.</span><span class="n">begin</span><span class="p">()){}</span>
	<span class="n">u32</span> <span class="nf">val</span><span class="p">()</span><span class="k">const</span><span class="p">{</span><span class="k">return</span> <span class="n">mtg</span><span class="p">.</span><span class="n">val</span><span class="p">(</span><span class="n">z</span><span class="p">);}</span>
	<span class="cp">#define mkopt_mint(star,mul)\
	mint operator star(mint const rhs)const{return{mtg.mul(z,rhs.z)};}\
	mint&amp;operator star##=(mint const rhs){z=mtg.mul(z,rhs.z);return*this;}
</span>	<span class="n">mkopt_mint</span><span class="p">(</span><span class="o">+</span><span class="p">,</span><span class="n">add</span><span class="p">)</span><span class="n">mkopt_mint</span><span class="p">(</span><span class="o">-</span><span class="p">,</span><span class="n">sub</span><span class="p">)</span><span class="n">mkopt_mint</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="n">mul</span><span class="p">)</span>
<span class="p">};</span>
<span class="kr">inline</span> <span class="n">mint</span><span class="o">&amp;</span><span class="k">operator</span><span class="o">%=</span><span class="p">(</span><span class="n">mint</span><span class="o">&amp;</span><span class="n">_</span><span class="p">,</span><span class="n">Barrett</span><span class="p">){</span><span class="k">return</span> <span class="n">_</span><span class="p">;}</span>
<span class="kr">inline</span> <span class="n">mint</span> <span class="k">operator</span><span class="o">%</span><span class="p">(</span><span class="n">mint</span> <span class="n">_</span><span class="p">,</span><span class="n">Barrett</span><span class="p">){</span><span class="k">return</span> <span class="n">_</span><span class="p">;}</span>



<span class="kt">signed</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">q</span><span class="p">;</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">a</span><span class="o">&gt;&gt;</span><span class="n">b</span><span class="o">&gt;&gt;</span><span class="n">q</span><span class="p">;</span>
	<span class="n">assert</span><span class="p">(</span><span class="n">q</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">mtg</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="n">cerr</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">mint</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">mint</span><span class="p">(</span><span class="n">b</span><span class="p">)).</span><span class="n">val</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
	<span class="n">cerr</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="o">%</span><span class="n">mod</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>

	<span class="n">mt19937</span> <span class="n">rng</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
		<span class="n">a</span><span class="o">=</span><span class="n">rng</span><span class="p">()</span><span class="o">%</span><span class="n">mod</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="n">rng</span><span class="p">()</span><span class="o">%</span><span class="n">mod</span><span class="p">;</span>
		<span class="n">assert</span><span class="p">((</span><span class="kt">size_t</span><span class="p">)</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="o">%</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">mod</span> <span class="o">==</span> <span class="p">(</span><span class="n">mint</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">mint</span><span class="p">(</span><span class="n">b</span><span class="p">)).</span><span class="n">val</span><span class="p">());</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<p>mtg要求mod&amp;1，然后bar约减没有这个要求。</p>

<p>https://blog.rogery.dev/post/learn-fastmod/</p>

<h2 id="优化取模的几种方法">优化取模的几种方法</h2>

<p>2023 年 2 月 7 日</p>

<p>取模是很慢的，尤其是当模数是动态的数时。</p>

<p>我没学过误差分析，大概讲法很民科（</p>

<h2 id="浮点实现">浮点实现</h2>

<p>显然有等式</p>

<p>a mod m=a−⌊am⌋ma \bmod m = a - \left\lfloor \frac{a}{m} \right\rfloor mamodm=a−⌊ma​⌋m</p>

<p>一般情况下是 mmm 是 <code class="language-plaintext highlighter-rouge">i32</code> 范围，且 a∈[0,m2)a \in [0, m^2)a∈[0,m2)，最简单的实现方式就是浮点除法。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct ModF {
  u32 m;
  f64 ivm;
  ModF(i32 m_) : m(m_), ivm(1.0 / m) {}
  u32 calc(u64 a) const {
    u32 r = a - i64(a * ivm) * m;
    if (r &gt;= m)
      r -= m;
    if (r &lt; 0)
      r += m;
    return r;
  }
};

</code></pre></div></div>

<h2 id="barrett-reduction">Barrett Reduction</h2>

<p>考虑除法的一个替代，选取 q,sq, sq,s 使得等式</p>

<p>⌊a/m⌋=⌊aq2s⌋,q≈2sm\lfloor a/m \rfloor = \left\lfloor \frac{aq}{2^s} \right\rfloor, \quad q \approx \frac{2^s}{m}⌊a/m⌋=⌊2saq​⌋,q≈m2s​</p>

<p>对尽可能多的 aaa 成立。由于 aaa 是整数，设误差是</p>

<p>q2s=1m+ε\frac{q}{2^s} = \frac{1}{m} + \varepsilon 2sq​=m1​+ε</p>

<p>当满足 0⩽aε&lt;1m0 \leqslant a\varepsilon &lt; \frac{1}{m}0⩽aε&lt;m1​ 则除法是精确的，因此选择</p>

<p>q=⌈2sm⌉=⌊2s+m−1m⌋q = \left\lceil \frac{2^s}{m} \right\rceil = \left\lfloor \frac{2^s + m - 1}{m} \right\rfloorq=⌈m2s​⌉=⌊m2s+m−1​⌋</p>

<p>是比较方便的。可以推得</p>

<p>ε=q2s−1m&lt;2s+m−12sm−1m=m−1m2s&lt;ε‾\varepsilon = \frac{q}{2^s} - \frac{1}{m} &lt; \frac{2^s + m - 1}{2^sm} -\frac{1}{m} = \frac{m-1}{m 2^s} &lt; \overline{\varepsilon}ε=2sq​−m1​&lt;2sm2s+m−1​−m1​=m2sm−1​&lt;ε</p>

<p>化简得到 2s&gt;m−1mε‾2^s &gt; \frac{m - 1}{m \overline{\varepsilon}}2s&gt;mεm−1​。假如 a∈[0,m2)a \in [0, m^2)a∈[0,m2)，大概需要 s≈3log⁡2ms \approx 3\log_2 ms≈3log2​m。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct Barrett {
  enum { s = 96 };
  static constexpr u128 s2 = u128(1) &lt;&lt; s;
  u32 m;
  u128 ivm;
  Barrett(u32 m_) : m(m_), ivm((s2 - 1) / m + 1) {}
  u32 div(u64 a) const {
    return a * ivm &gt;&gt; s;
  }
  u32 calc(u64 a) const {
    return a - u64(div(a)) * m;
  }
};

</code></pre></div></div>

<h3 id="乘定值">乘定值</h3>

<p>倘若我们要计算 a×b mod ma \times b \bmod ma×bmodm，其中 bbb 是定值，可以把上式的一部分合并。</p>

<p>推导过程没什么区别，重新考虑带入式，仍选择</p>

<p>q=⌈2sbm⌉=⌊2sb+m−1m⌋q = \left\lceil \frac{2^sb}{m} \right\rceil = \left\lfloor \frac{2^sb + m - 1}{m} \right\rfloorq=⌈m2sb​⌉=⌊m2sb+m−1​⌋</p>

<p>由于 aaa 是整数，设误差是</p>

<p>q2s=bm+ε\frac{q}{2^s} = \frac{b}{m} + \varepsilon 2sq​=mb​+ε</p>

<p>当满足 0⩽aε&lt;1m0 \leqslant a\varepsilon &lt; \frac{1}{m}0⩽aε&lt;m1​ 则除法是精确的。推得</p>

<p>ε=q2s−bm&lt;2sb+m−12sm−bm=m−1m2s&lt;ε‾\varepsilon = \frac{q }{2^s} - \frac{b}{m} &lt; \frac{2^sb + m - 1}{2^s m} -\frac{b}{m} = \frac{m-1}{m 2^s} &lt; \overline{\varepsilon}ε=2sq​−mb​&lt;2sm2sb+m−1​−mb​=m2sm−1​&lt;ε</p>

<p>化简得到 2s&gt;m−1mε‾2^s &gt; \frac{m - 1}{m \overline{\varepsilon}}2s&gt;mεm−1​。假如 a∈[0,m)a \in [0, m)a∈[0,m)，大概需要 s≈2log⁡2ms \approx 2\log_2 ms≈2log2​m。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct MulBarrett {
  enum { s = 64 };
  static constexpr u128 s2 = u128(1) &lt;&lt; s;
  u32 b, m;
  u64 ivm;
  MulBarrett(u32 b_, u32 m_) : b(b_), m(m_), ivm((s2 * b - 1) / m + 1) {}
  u64 div(u64 a) const {
    return u128(a) * ivm &gt;&gt; s;
  }
  u32 calc(u32 a) const {
    return a * b - u64(div(a)) * m;
  }
};

</code></pre></div></div>

<h3 id="调整">调整</h3>

<p>取模可以没必要一次到位。</p>

<p>考虑一次调整（是调整取模结果，除法无法调整），即令 0⩽ε&lt;1m0 \leqslant \varepsilon &lt; \frac{1}{m}0⩽ε&lt;m1​，可以得到 2s&gt;a−a/m2^s &gt; a - a / m2s&gt;a−a/m，例如当 a∈[0,m)a \in [0, m)a∈[0,m) 时有 s≈log⁡2ms \approx \log_2 ms≈log2​m。</p>

<p>因此，定值乘法可以仅在 <code class="language-plaintext highlighter-rouge">u64</code> 下进行；若通过特殊的手段得到进位标志，<code class="language-plaintext highlighter-rouge">u64</code> 取模也是能仅在 <code class="language-plaintext highlighter-rouge">u64</code> 下完成的。</p>

<p>因为允许调整，也就不必拘泥于向上取整，向下取整也是可以实现的。</p>

<h2 id="lemire-reduction">Lemire Reduction</h2>

<p>取模结果可以更直接的获得</p>

<p>r=⌊(am−⌊am⌋)m⌋=⌊(aq2s−aε−⌊aqm−aε⌋)m⌋=⌊(aq−⌊aq2s−aε⌋2s−2saε)m2s⌋\begin{aligned} r &amp;= \left\lfloor \left(\frac{a}{m} - \left\lfloor \frac{a}{m} \right\rfloor \right) m \right\rfloor \\ &amp;= \left\lfloor \left(\frac{aq}{2^s} - a \varepsilon - \left\lfloor \frac{aq}{m} - a \varepsilon \right\rfloor \right) m \right\rfloor \\ &amp;= \left\lfloor \left(aq - \left\lfloor \frac{aq}{2^s} - a \varepsilon \right\rfloor 2^s - 2^s a \varepsilon \right) \frac{m}{2^s} \right\rfloor \end{aligned}r​=⌊(ma​−⌊ma​⌋)m⌋=⌊(2saq​−aε−⌊maq​−aε⌋)m⌋=⌊(aq−⌊2saq​−aε⌋2s−2saε)2sm​⌋​</p>

<p>假定除法精确，即 0⩽aε&lt;1m0 \leqslant a \varepsilon &lt; \frac{1}{m}0⩽aε&lt;m1​，注意到这里可以化成取模</p>

<p>r=⌊(aq mod 2s)⋅m2s+aεm⌋=⌊(aq mod 2s)⋅m2s⌋\begin{aligned} r &amp;= \left\lfloor \frac{(aq \bmod 2^s) \cdot m}{2^s} + a\varepsilon m \right\rfloor \\ &amp;= \left\lfloor \frac{(aq \bmod 2^s) \cdot m }{2^s} \right\rfloor \end{aligned}r​=⌊2s(aqmod2s)⋅m​+aεm⌋=⌊2s(aqmod2s)⋅m​⌋​</p>

<p>精度还是 s≈3log⁡2ms \approx 3\log_2 ms≈3log2​m。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct Lemire {
  enum { s = 96 };
  static constexpr u128 s2 = u128(1) &lt;&lt; s;
  u32 m;
  u128 q;
  Lemire(u32 m_) : m(m_), q((s2 - 1) / m + 1) {}
  u32 calc(u64 a) const {
    return a * q % s2 * u128(m) &gt;&gt; s;
  }
};

</code></pre></div></div>

<h3 id="乘定值-1">乘定值</h3>

<p>同样推导</p>

<p>r=⌊(aq−⌊aq2s−aε⌋2s−2saε)m2s⌋=⌊(aq mod 2s)⋅m2s⌋\begin{aligned} r &amp;= \left\lfloor \left(aq - \left\lfloor \frac{aq}{2^s} - a \varepsilon \right\rfloor 2^s - 2^s a \varepsilon \right) \frac{m}{2^s} \right\rfloor \\ &amp;= \left\lfloor \frac{(aq \bmod 2^s) \cdot m }{2^s} \right\rfloor \end{aligned}r​=⌊(aq−⌊2saq​−aε⌋2s−2saε)2sm​⌋=⌊2s(aqmod2s)⋅m​⌋​</p>

<p>精度仍是除法精确的 s≈2log⁡2ms \approx 2\log_2 ms≈2log2​m。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct MulLemire {
  enum { s = 64 };
  static constexpr u128 s2 = u128(1) &lt;&lt; s;
  u32 b, m;
  u64 q;
  MulLemire(u32 b_, u32 m_) : b(b_), m(m_), q((s2 * b - 1) / m + 1) {}
  u32 calc(u32 a) const {
    return a * q * u128(m) &gt;&gt; s;
  }
};

</code></pre></div></div>

<h3 id="调整-1">调整</h3>

<p>Lemire Reduction 无法调整。</p>

<p>前面能调整是因为除法误差为 1，所以取模后只会差 mmm 的倍数；这里直接算出了取模，差了 1 差了 2 你也没办法校正，所以无法调整。</p>

<h2 id="montgomery-multiplication">Montgomery multiplication</h2>

<p>Montgomery multiplication 能够更好的利用 SIMD 加速，编译器也能够自动向量化。</p>

<p>带调整的 Barrett 乘定值优化由于不涉及 <code class="language-plaintext highlighter-rouge">u128</code>，编译器也能够向量化，但除法的代价较高，总之还是不太行。</p>

<h3 id="montgomery-空间">Montgomery 空间</h3>

<p>设常数 rrr 满足 gcd⁡(r,m)=1 \gcd(r, m) = 1gcd(r,m)=1 且 r⩾mr \geqslant mr⩾m，一般选择 2642^{64}264 或 2322^{32}232。</p>

<p>定义 xxx 在 Montgomery 空间中的值为</p>

<p>x‾=xr mod m\overline{x} = xr \bmod mx=xrmodm</p>

<p>加减是平凡的</p>

<p>x‾±y‾=(x±y)r mod m\overline{x} \pm \overline{y} = (x \pm y) r \bmod mx±y​=(x±y)rmodm</p>

<p>乘法有些特殊</p>

<p>x‾∗y‾=xyr=x‾⋅y‾⋅r−1 mod m\overline{x} \ast \overline{y} = xy r = \overline{x} \cdot \overline{y} \cdot r^{-1} \bmod mx∗y​=xyr=x⋅y​⋅r−1modm</p>

<p>因此关键在于两个函数：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">transform</code>：计算 x⋅r mod mx \cdot r \bmod mx⋅rmodm；</li>
  <li><code class="language-plaintext highlighter-rouge">reduce</code>：计算 x⋅r−1 mod mx \cdot r^{-1} \bmod mx⋅r−1modm。</li>
</ul>

<h3 id="reduce">Reduce</h3>

<p>Montgomery 指出了除 2 不需要除法：</p>

<p>a2 mod m={a2,a 是偶数a+m2,a 是奇数\frac{a}{2} \bmod m = \begin{cases} \frac{a}{2} &amp;, a \text{ 是偶数} \\ \frac{a + m}{2} &amp;, a\text{ 是奇数} \\ \end{cases}2a​modm={2a​2a+m​​,a 是偶数,a 是奇数​</p>

<p>且例如 r=232r = 2^{32}r=232 时</p>

<p>a−a≡a−m(am−1)≡0(modr)a - a \equiv a - m (a m^{-1}) \equiv 0 \pmod ra−a≡a−m(am−1)≡0(modr)</p>

<p>因此设置 μ=−m−1 mod r\mu = -m^{-1} \bmod rμ=−m−1modr，有</p>

<p>xr−1≡x+m(xμ mod r)r(modm)x r^{-1} \equiv \frac{x + m(x\mu \bmod r)}{r} \pmod m xr−1≡rx+m(xμmodr)​(modm)</p>

<p>再考虑值域，发现上式小于 2m2m2m。但是中间运算的没必要求值，可以惰性一点，最后映出时再规整。</p>

<h3 id="transform">Transform</h3>

<p>一般输入都是 [0,m)[0, m)[0,m)，直接乘就行；也可以利用 reduction，但是不会更优。</p>

<p>或许可以尝试用 Barrett 优化一下？我没测试过，猜想带调整的更快一点。</p>

<h3 id="更快的-2k2k2k-逆元">更快的 2k2^k2k 逆元</h3>

<p>在 rrr 是 222 的幂次时，逆元可以用牛顿迭代。假设 xxx 是 aaa 在 2k2^k2k 下的逆元</p>

<p>ax≡2kq+1(mod22k)ax \equiv 2^k q + 1 \pmod {2^{2k}}ax≡2kq+1(mod22k)</p>

<p>那么</p>

<p>ax(2−ax)≡1−22kq2≡1(mod22k)ax(2-ax) \equiv 1 - 2^{2k}q^2 \equiv 1 \pmod {2^{2k}}ax(2−ax)≡1−22kq2≡1(mod22k)</p>

<h2 id="实现">实现</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct Montgomery {
  u32 m, ir;
  static u32 inv_m(u32 m) {
    u32 x = 1;
    for (i32 i = 0; i &lt; 5; ++i)
      x *= 2 - x * m;
    return x;
  }
  Montgomery(u32 m_) : m(m_), ir(-inv_m(m)) {}
  u32 tran(u32 a) const {
    return (u64(a) &lt;&lt; 32) % m;
  }
  u32 val(u32 a) const { // itrans
    return redc_m(redc(a) - m);
  }
  u32 add(u32 a, u32 b) const {
    return redc_m2(a + b - m * 2);
  }
  u32 sub(u32 a, u32 b) const {
    return redc_m2(a - b);
  }
  u32 redc_m(u32 a) const {
    return a &gt;&gt; 31 ? a + m : a;
  }
  u32 redc_m2(u32 a) const {
    return a &gt;&gt; 31 ? a + m * 2 : a;
  }
  u32 redc(u64 a) const {
    return (a + u64(u32(a) * ir) * m) &gt;&gt; 32;
  }
  u32 mul(u32 a, u32 b) const {
    return redc(u64(a) * b);
  }
};

</code></pre></div></div>

<h2 id="其他">其他</h2>

<p><a href="https://www.luogu.com.cn/blog/plateIet/modulo-proof">@platelet</a> 在他的博客 <a href="https://www.luogu.com.cn/blog/plateIet/modulo">速度是编译器实现两倍的取模算法</a> 中提到了 Lemire Reduction 的乘定值优化。但是除法的代价太高，在长 nnn 的 NTT 中有 O(n)O(n)O(n) 个单位根需要处理，并不能表现出优势。反到是 Barrett 更优一点。</p>

<p>除法代价高，初始化或许可以再套一次 Barrett？下次有空了试试。</p>

<h2 id="参考">参考</h2>

<ul>
  <li><a href="https://en.wikipedia.org/wiki/Barrett_reduction">https://en.wikipedia.org/wiki/Barrett_reduction</a></li>
  <li><a href="https://en.algorithmica.org/hpc/arithmetic/division/">https://en.algorithmica.org/hpc/arithmetic/division/</a></li>
  <li><a href="https://arxiv.org/pdf/1407.3383.pdf">https://arxiv.org/pdf/1407.3383.pdf</a></li>
</ul>

<p>本文转自 <a href="https://blog.rogery.dev/post/learn-fastmod/">https://blog.rogery.dev/post/learn-fastmod/</a>，如有侵权，请联系删除。
<!--stackedit_data:
eyJoaXN0b3J5IjpbOTg5ODcxNjcwLDc2NzY0MTk2MV19
--></p>]]></content><author><name>Orlicz</name></author><summary type="html"><![CDATA[快速取模数]]></summary></entry><entry><title type="html">Rmq</title><link href="//github-yet.orlicz.top/jekyll-theme-yat/2024/12/03/rmq.html" rel="alternate" type="text/html" title="Rmq" /><published>2024-12-03T00:00:00+00:00</published><updated>2024-12-03T00:00:00+00:00</updated><id>//github-yet.orlicz.top/jekyll-theme-yat/2024/12/03/rmq</id><content type="html" xml:base="//github-yet.orlicz.top/jekyll-theme-yat/2024/12/03/rmq.html"><![CDATA[<h3 id="rmq">RMQ</h3>

<p>线性RMQ的速度是很差的，原因是，内存是新的硬盘。</p>

<p>我可以在1s内执行1e9次cpu密集的任务，但rmq的瓶颈在于访问内存</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define lg(x) (31^__builtin_clz(x))
#define ctz __builtin_ctz
</span><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">maxn</span><span class="p">],</span><span class="n">st</span><span class="p">[</span><span class="n">__lg</span><span class="p">(</span><span class="n">maxn</span><span class="p">)</span><span class="o">-</span><span class="mi">4</span><span class="p">][</span><span class="n">maxn</span><span class="o">&gt;&gt;</span><span class="mi">5</span><span class="p">];</span>
<span class="kt">unsigned</span> <span class="n">msk</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span>
<span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
	<span class="kt">unsigned</span> <span class="n">cur</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">bas</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">i</span><span class="o">&amp;</span><span class="mi">31</span><span class="p">))</span><span class="n">cur</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">bas</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
		<span class="k">while</span><span class="p">(</span><span class="n">cur</span><span class="o">&amp;&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">a</span><span class="p">[</span><span class="n">bas</span><span class="o">|</span><span class="n">lg</span><span class="p">(</span><span class="n">cur</span><span class="p">)])</span><span class="n">cur</span><span class="o">^=</span><span class="mi">1u</span><span class="o">&lt;&lt;</span><span class="n">lg</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
		<span class="n">msk</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">cur</span><span class="o">|=</span><span class="mi">1u</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">bas</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">bas</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="n">bas</span><span class="o">+=</span><span class="mi">32</span><span class="p">)</span><span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">bas</span><span class="o">&gt;&gt;</span><span class="mi">5</span><span class="p">]</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="n">bas</span><span class="o">|</span><span class="n">ctz</span><span class="p">(</span><span class="n">msk</span><span class="p">[</span><span class="n">bas</span><span class="o">|</span><span class="mi">31</span><span class="p">])];</span>
	<span class="o">--</span><span class="n">n</span><span class="p">;</span><span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">n</span><span class="o">&gt;&gt;</span><span class="mi">5</span><span class="p">]</span><span class="o">=</span><span class="n">a</span><span class="p">[(</span><span class="n">n</span><span class="o">&amp;~</span><span class="mi">31</span><span class="p">)</span><span class="o">|</span><span class="n">ctz</span><span class="p">(</span><span class="n">msk</span><span class="p">[</span><span class="n">n</span><span class="p">])];</span><span class="n">n</span><span class="o">&gt;&gt;=</span><span class="mi">5</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">)</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">)</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">min</span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">))]);</span>
<span class="p">}</span>
<span class="k">auto</span> <span class="nf">qmin</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="kt">int</span> <span class="n">r</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">ql</span><span class="o">=</span><span class="n">l</span><span class="o">&gt;&gt;</span><span class="mi">5</span><span class="p">,</span><span class="n">qr</span><span class="o">=</span><span class="n">r</span><span class="o">&gt;&gt;</span><span class="mi">5</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">ql</span><span class="o">==</span><span class="n">qr</span><span class="p">)</span><span class="k">return</span> <span class="n">a</span><span class="p">[(</span><span class="n">l</span><span class="o">&amp;~</span><span class="mi">31</span><span class="p">)</span><span class="o">|</span><span class="n">ctz</span><span class="p">(</span><span class="n">msk</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">l</span><span class="o">&amp;</span><span class="mi">31</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">l</span><span class="o">&amp;</span><span class="mi">31</span><span class="p">))];</span>
	<span class="cp">#define _0 a[(l&amp;~31)|ctz(msk[l|31]&gt;&gt;(l&amp;31)&lt;&lt;(l&amp;31))]
</span>	<span class="cp">#define _1 a[(r&amp;~31)|ctz(msk[r])]
</span>	<span class="k">if</span><span class="p">(</span><span class="n">ql</span><span class="o">+</span><span class="mi">1</span><span class="o">==</span><span class="n">qr</span><span class="p">)</span><span class="k">return</span> <span class="n">min</span><span class="p">(</span><span class="n">_0</span><span class="p">,</span><span class="n">_1</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">g</span><span class="o">=</span><span class="n">lg</span><span class="p">(</span><span class="n">qr</span><span class="o">-</span><span class="n">ql</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">auto</span> <span class="n">va</span><span class="o">=</span><span class="n">min</span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="n">g</span><span class="p">][</span><span class="n">ql</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">st</span><span class="p">[</span><span class="n">g</span><span class="p">][</span><span class="n">qr</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">g</span><span class="p">)]);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">va</span><span class="o">==</span><span class="n">min</span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="n">g</span><span class="p">][</span><span class="n">ql</span><span class="p">],</span><span class="n">st</span><span class="p">[</span><span class="n">g</span><span class="p">][</span><span class="n">qr</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">g</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span><span class="k">return</span> <span class="n">va</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">min</span><span class="p">(</span><span class="n">va</span><span class="p">,</span><span class="n">min</span><span class="p">(</span><span class="n">_0</span><span class="p">,</span><span class="n">_1</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>随机情况下，唐诗的事情是，1024分段然后求解这个的复杂度最好。（1024=sqrt）。</p>

<p>但是为什么要放任一个空间常数巨大的做法呢？</p>

<p>上述的rmq瓶颈在于内存访问。人们难以加快它。如果真的需要加快，可以采用将a和msk等信息并列的方法。（但是不会有多少收益）</p>

<p>这个rmq速度是上乘的，一个优化还是我在github上学习的。</p>

<p>随机rmq没有意义。</p>

<hr />

<p>之前cf有一个好题，内容是，就是昨天的div2</p>

<p>最后一个题目我一下子就做出来了。主要就是线性的。可能的瓶颈是LCA。</p>

<p>转化成有根树，然后考虑对于指定的连通块求解信息。</p>

<p>还好吧。注意今天的cf!
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTQwOTQ5NTk4Ml19
--></p>]]></content><author><name>Orlicz</name></author><summary type="html"><![CDATA[RMQ]]></summary></entry><entry><title type="html">Talks</title><link href="//github-yet.orlicz.top/jekyll-theme-yat/2024/12/02/talks.html" rel="alternate" type="text/html" title="Talks" /><published>2024-12-02T00:00:00+00:00</published><updated>2024-12-02T00:00:00+00:00</updated><id>//github-yet.orlicz.top/jekyll-theme-yat/2024/12/02/talks</id><content type="html" xml:base="//github-yet.orlicz.top/jekyll-theme-yat/2024/12/02/talks.html"><![CDATA[<p>kde is goo
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTgzNDk5NjQ0MSwtMjA4ODc0NjYxMl19
--></p>]]></content><author><name>Orlicz</name></author><summary type="html"><![CDATA[kde is goo]]></summary></entry><entry><title type="html">Noip</title><link href="//github-yet.orlicz.top/jekyll-theme-yat/2024/11/30/noip.html" rel="alternate" type="text/html" title="Noip" /><published>2024-11-30T00:00:00+00:00</published><updated>2024-11-30T00:00:00+00:00</updated><id>//github-yet.orlicz.top/jekyll-theme-yat/2024/11/30/noip</id><content type="html" xml:base="//github-yet.orlicz.top/jekyll-theme-yat/2024/11/30/noip.html"><![CDATA[<h2 id="noip">NOIP</h2>

<p>14:32</p>

<p>noip 结束了。真唐。100+100+56+100。大样例我要0.9s，但是山东理工的机子快，也不知道是不是大样例弱小。</p>

<p>人们宣传pak,cak。/se。哈哈哈哈</p>

<p>远离，yuanli, yuan li.
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTEzMDYxODI1NywzMjA3MDE4MTJdfQ==
--></p>]]></content><author><name>Orlicz</name></author><summary type="html"><![CDATA[NOIP]]></summary></entry><entry><title type="html">Some Tech</title><link href="//github-yet.orlicz.top/jekyll-theme-yat/2024/11/30/some-tech.html" rel="alternate" type="text/html" title="Some Tech" /><published>2024-11-30T00:00:00+00:00</published><updated>2024-11-30T00:00:00+00:00</updated><id>//github-yet.orlicz.top/jekyll-theme-yat/2024/11/30/some-tech</id><content type="html" xml:base="//github-yet.orlicz.top/jekyll-theme-yat/2024/11/30/some-tech.html"><![CDATA[<h1 id="浅谈一些科技">浅谈一些科技</h1>

<h2 id="本站">本站</h2>

<p>我使用我两年之前的设计，我发现yat主题却是十分简洁大方。</p>

<p>我将会浅谈一些看上去比较需要记住的科技</p>

<p>请及时与我联系。（如果需要。）联系方式是公开发表言论，并且等待我看到的那一天。</p>

<h2 id="spj">spj</h2>

<p>对于spj的书写，往往是搞笑的。因为每个oj都不同。</p>

<p>testlib一家独大，这是不好的。我因此设计了 testlib-lite:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">Result</span><span class="p">{</span>
	<span class="n">_ok</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">_wa</span><span class="o">=</span><span class="mi">1</span>
<span class="p">};</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span><span class="nc">A</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">pit_impl</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="n">it</span><span class="p">,</span><span class="n">A</span><span class="p">...</span><span class="n">a</span><span class="p">){</span>
	<span class="n">cerr</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">strtok</span><span class="p">(</span><span class="n">it</span><span class="p">,</span><span class="s">"%"</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)(</span><span class="n">cerr</span><span class="o">&lt;&lt;</span><span class="p">...</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">cerr</span><span class="o">&lt;&lt;</span><span class="n">a</span><span class="p">,</span><span class="n">strtok</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="s">"%"</span><span class="p">)));</span>
<span class="p">}</span>
<span class="cp">#define pit(a,b...) pit_impl(&amp;(" " a##s[0]),##b)
#define exit(sig,va...) pit("exit("#sig "): " va),_exit(sig)
#define sure(cond,va...) !(cond)&amp;&amp;(exit(_wa,"sure("#cond "): " va),1)
</span><span class="c1">// enum</span>
<span class="c1">//do not use %%.</span>

<span class="n">ifstream</span> <span class="n">fin</span><span class="p">,</span><span class="n">out</span><span class="p">,</span><span class="n">ans</span><span class="p">;</span>
<span class="cp">#define cin fin
</span>
<span class="kt">void</span> <span class="nf">arginit</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span><span class="kt">char</span><span class="o">*</span><span class="n">argv</span><span class="p">[]){</span>
	<span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">sure</span><span class="p">(</span><span class="n">argc</span><span class="o">==</span><span class="mi">4</span><span class="p">);</span>
	<span class="n">fin</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">out</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span><span class="n">ans</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
	<span class="n">atexit</span><span class="p">(</span><span class="o">+</span><span class="p">[](){</span><span class="n">cerr</span><span class="o">&lt;&lt;</span><span class="s">"ok "</span><span class="p">;});</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">presol</span><span class="p">(){</span>

<span class="p">}</span>
<span class="kt">bool</span> <span class="nf">sol</span><span class="p">(</span><span class="n">ifstream</span><span class="o">&amp;</span><span class="n">cin</span><span class="p">){</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>



<span class="kt">signed</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span><span class="kt">char</span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
<span class="n">pit</span><span class="p">(</span>
<span class="s">R"(hello!
"trust spj" by %.
% is a placement, like % in printf
systime: %
argc: %, argv[0]: %
warning: %
)"</span><span class="p">,</span><span class="s">"me"</span><span class="p">,</span><span class="sc">'%'</span><span class="p">,</span><span class="sc">'%'</span><span class="p">,</span><span class="n">time</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">argc</span><span class="p">,</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s">"do not using %%, it makes trouble."</span><span class="n">s</span>
<span class="p">);</span>
	<span class="n">arginit</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span><span class="n">argv</span><span class="p">);</span>

	
	<span class="c1">// presol();</span>
	<span class="c1">// sure(sol(out)==sol(ans));</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="allocator">allocator</h2>

<p>allocator 是没有意义的，手动实现它没有用处。</p>

<p>但是这确实是一个复杂的项目，对不对啊</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">maxn</span> <span class="o">=</span> <span class="mf">2e5</span><span class="o">+</span><span class="mi">10</span><span class="p">;</span>

<span class="k">constexpr</span> <span class="kt">int</span> <span class="n">G</span><span class="o">=</span><span class="mi">24</span><span class="p">;</span>
<span class="cp">#define __lg32(x) (31^__builtin_clz(unsigned(x)))
</span><span class="k">using</span> <span class="n">uint</span> <span class="o">=</span> <span class="kt">unsigned</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">G</span><span class="p">];</span>
<span class="k">struct</span> <span class="nc">node</span><span class="p">{</span>
	<span class="kt">int</span><span class="o">*</span><span class="n">p1</span><span class="p">,</span><span class="o">*</span><span class="n">p2</span><span class="p">;</span>
<span class="p">}</span><span class="n">blk</span><span class="p">[</span><span class="mi">2</span><span class="o">&lt;&lt;</span><span class="n">G</span><span class="p">];</span>
<span class="k">struct</span> <span class="nc">rang</span><span class="p">{</span>
	<span class="n">node</span><span class="o">*</span><span class="n">p1</span><span class="p">,</span><span class="o">*</span><span class="n">p2</span><span class="p">;</span><span class="c1">//next: opt out this.</span>
<span class="p">}</span><span class="n">mbr</span><span class="p">[</span><span class="n">G</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="n">uint</span> <span class="n">msk</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">init</span><span class="p">(){</span>
	<span class="n">blk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="n">buf</span><span class="p">,</span><span class="n">end</span><span class="p">(</span><span class="n">buf</span><span class="p">)};</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">G</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">){</span>
		<span class="n">mbr</span><span class="p">[</span><span class="n">G</span><span class="o">-</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="n">blk</span><span class="o">+</span><span class="p">((</span><span class="n">i</span><span class="o">?</span><span class="mi">2</span><span class="o">:</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">blk</span><span class="o">+</span><span class="p">(</span><span class="mi">2</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">};</span>
	<span class="p">}</span>
	<span class="n">msk</span><span class="o">=</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">G</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">int</span><span class="o">*</span> <span class="nf">fmalloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span><span class="k">noexcept</span><span class="p">{</span>
	<span class="n">uint</span> <span class="n">let</span><span class="o">=</span><span class="n">n</span><span class="o">==</span><span class="mi">1</span><span class="o">?</span><span class="mi">1</span><span class="o">:</span><span class="mi">2</span><span class="o">&lt;&lt;</span><span class="n">__lg32</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">__builtin_ctz</span><span class="p">(</span><span class="n">msk</span><span class="o">&amp;~</span><span class="p">(</span><span class="n">let</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
	<span class="n">node</span><span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="n">mbr</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">p1</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">mbr</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">p2</span><span class="o">==</span><span class="n">mbr</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">p1</span><span class="p">)</span><span class="n">msk</span><span class="o">^=</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">k</span><span class="p">;</span>
	<span class="kt">int</span><span class="o">*</span><span class="n">res</span><span class="o">=</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p1</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">p1</span><span class="o">+=</span><span class="n">n</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p1</span><span class="o">&lt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p2</span><span class="p">){</span>
		<span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">__lg32</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p2</span><span class="o">-</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p1</span><span class="p">);</span>
		<span class="n">msk</span><span class="o">|=</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">k</span><span class="p">;</span>
		<span class="k">auto</span> <span class="n">q</span><span class="o">=--</span><span class="n">mbr</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">p1</span><span class="p">;</span>
		<span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="o">*</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p1</span> <span class="o">=</span> <span class="n">uint</span><span class="p">(</span><span class="n">q</span><span class="o">-</span><span class="n">blk</span><span class="p">);</span>
	<span class="p">}</span><span class="k">else</span><span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="p">{};</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">inblk</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span><span class="p">){</span><span class="k">return</span> <span class="n">i</span><span class="o">&lt;</span><span class="p">(</span><span class="k">sizeof</span> <span class="n">blk</span><span class="o">/</span><span class="k">sizeof</span> <span class="n">blk</span><span class="p">[</span><span class="mi">0</span><span class="p">]);}</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">ffree</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span><span class="k">noexcept</span><span class="p">{</span>
	<span class="kt">int</span><span class="o">*</span><span class="n">bg</span><span class="o">=</span><span class="n">p</span><span class="p">,</span><span class="o">*</span><span class="n">ed</span><span class="o">=</span><span class="n">p</span><span class="o">+</span><span class="n">n</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="n">buf</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">inblk</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">auto</span><span class="o">&amp;</span><span class="n">cur</span><span class="o">=</span><span class="n">blk</span><span class="p">[</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="mi">1</span><span class="p">)];</span>
			<span class="k">if</span><span class="p">(</span><span class="n">cur</span><span class="p">.</span><span class="n">p2</span><span class="o">==</span><span class="n">p</span><span class="p">){</span>
				<span class="n">bg</span><span class="o">=</span><span class="n">cur</span><span class="p">.</span><span class="n">p1</span><span class="p">;</span>
				<span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">__lg32</span><span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="n">bg</span><span class="p">);</span>
				<span class="n">cur</span><span class="o">=*</span><span class="p">(</span><span class="n">mbr</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">p1</span><span class="o">++</span><span class="p">);</span>
				<span class="k">if</span><span class="p">(</span><span class="n">mbr</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">p1</span><span class="o">==</span><span class="n">mbr</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">p2</span><span class="p">)</span><span class="n">msk</span><span class="o">^=</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">k</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">inblk</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">n</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">auto</span><span class="o">&amp;</span><span class="n">cur</span><span class="o">=</span><span class="n">blk</span><span class="p">[</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">n</span><span class="p">)];</span>
			<span class="k">if</span><span class="p">(</span><span class="n">cur</span><span class="p">.</span><span class="n">p1</span><span class="o">==</span><span class="n">p</span><span class="o">+</span><span class="n">n</span><span class="p">){</span>
				<span class="n">ed</span><span class="o">=</span><span class="n">cur</span><span class="p">.</span><span class="n">p2</span><span class="p">;</span>
				<span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">__lg32</span><span class="p">(</span><span class="n">ed</span><span class="o">-</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">n</span><span class="p">));</span>
				<span class="n">cur</span><span class="o">=*</span><span class="p">(</span><span class="n">mbr</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">p1</span><span class="o">++</span><span class="p">);</span>
				<span class="k">if</span><span class="p">(</span><span class="n">mbr</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">p1</span><span class="o">==</span><span class="n">mbr</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">p2</span><span class="p">)</span><span class="n">msk</span><span class="o">^=</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">k</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">__lg32</span><span class="p">(</span><span class="n">ed</span><span class="o">-</span><span class="n">bg</span><span class="p">);</span>
	<span class="n">msk</span><span class="o">|=</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">k</span><span class="p">;</span>
	<span class="o">*--</span><span class="n">mbr</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">p1</span><span class="o">=</span><span class="p">{</span><span class="n">bg</span><span class="p">,</span><span class="n">ed</span><span class="p">};</span>
	<span class="o">*</span><span class="n">bg</span><span class="o">=*</span><span class="p">(</span><span class="n">ed</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">=</span><span class="n">uint</span><span class="p">(</span><span class="n">mbr</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">p1</span><span class="o">-</span><span class="n">blk</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">fallocator</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="k">typedef</span> <span class="n">T</span>           <span class="n">value_type</span><span class="p">;</span>
	<span class="k">typedef</span> <span class="n">T</span><span class="o">*</span>          <span class="n">pointer</span><span class="p">;</span>
	<span class="k">typedef</span> <span class="k">const</span> <span class="n">T</span><span class="o">*</span>    <span class="n">const_pointer</span><span class="p">;</span>
	<span class="k">typedef</span> <span class="n">T</span><span class="o">&amp;</span>          <span class="n">reference</span><span class="p">;</span>
	<span class="k">typedef</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span>    <span class="n">const_reference</span><span class="p">;</span>
	<span class="k">typedef</span> <span class="kt">size_t</span>      <span class="n">size_type</span><span class="p">;</span>
	<span class="k">typedef</span> <span class="kt">ptrdiff_t</span>   <span class="n">difference_type</span><span class="p">;</span>
	<span class="k">constexpr</span> <span class="k">static</span> <span class="n">size_type</span> <span class="n">rat</span><span class="o">=</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

	<span class="n">pointer</span> <span class="n">allocate</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="p">(</span><span class="n">pointer</span><span class="p">)</span><span class="n">fmalloc</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">rat</span><span class="p">);}</span>
	<span class="kt">void</span> <span class="nf">deallocate</span><span class="p">(</span><span class="n">pointer</span> <span class="n">p</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="n">ffree</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">,</span><span class="n">n</span><span class="o">*</span><span class="n">rat</span><span class="p">);</span> <span class="p">}</span> 
<span class="p">};</span>

<span class="k">namespace</span> <span class="n">test_zhihu</span><span class="p">{</span>
<span class="k">struct</span> <span class="nc">E</span> <span class="p">{</span><span class="kt">int</span> <span class="n">a</span><span class="p">;</span><span class="n">E</span><span class="p">(</span><span class="kt">int</span> <span class="n">aa</span><span class="p">)</span><span class="o">:</span><span class="n">a</span><span class="p">(</span><span class="n">aa</span><span class="p">){}};</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">alloc_t</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">test</span><span class="p">(</span><span class="n">alloc_t</span><span class="o">&amp;&amp;</span><span class="n">alloc</span><span class="o">=</span><span class="n">alloc_t</span><span class="p">())</span> <span class="p">{</span>
	<span class="n">cerr</span><span class="o">&lt;&lt;</span><span class="n">__PRETTY_FUNCTION__</span><span class="o">&lt;&lt;</span><span class="s">": "</span><span class="p">;</span>
	<span class="k">auto</span> <span class="n">cc</span><span class="o">=</span><span class="n">clock</span><span class="p">();</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ARRAY_COUNT</span> <span class="o">=</span> <span class="mi">1000L</span><span class="p">;</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">TEST_COUNT</span> <span class="o">=</span> <span class="n">ARRAY_COUNT</span> <span class="o">*</span> <span class="mi">100000L</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">E</span><span class="o">*</span> <span class="n">es</span><span class="p">[</span><span class="n">ARRAY_COUNT</span><span class="p">];</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">es</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="p">)</span><span class="o">*</span><span class="n">ARRAY_COUNT</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">TEST_COUNT</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">long</span> <span class="kt">long</span> <span class="n">idx</span><span class="o">=</span><span class="n">i</span><span class="o">*</span><span class="mi">123456789L</span><span class="o">%</span><span class="n">ARRAY_COUNT</span><span class="p">;</span>
		<span class="n">E</span><span class="o">*</span> <span class="n">e</span> <span class="o">=</span> <span class="n">es</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
		<span class="k">if</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="n">e</span><span class="o">-&gt;~</span><span class="n">E</span><span class="p">(),</span><span class="n">alloc</span><span class="p">.</span><span class="n">deallocate</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">es</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">alloc</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="k">new</span><span class="p">(</span><span class="n">es</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span><span class="n">E</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="kt">long</span> <span class="kt">long</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">ARRAY_COUNT</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">E</span><span class="o">*</span><span class="n">e</span><span class="o">=</span><span class="n">es</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="n">n</span><span class="o">+=</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cerr</span><span class="o">&lt;&lt;</span><span class="n">clock</span><span class="p">()</span><span class="o">-</span><span class="n">cc</span><span class="o">&lt;&lt;</span><span class="sc">' '</span><span class="o">&lt;&lt;</span><span class="n">n</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="k">namespace</span> <span class="n">test_stl_insertend</span> <span class="p">{</span>
	<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span><span class="kt">int</span> <span class="n">per</span><span class="o">=</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">18</span><span class="p">&gt;</span>
	<span class="kt">void</span> <span class="n">test</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="n">t</span><span class="p">,</span><span class="kt">unsigned</span> <span class="n">rnd</span><span class="p">){</span>
		<span class="n">cerr</span><span class="o">&lt;&lt;</span><span class="n">__PRETTY_FUNCTION__</span><span class="o">&lt;&lt;</span><span class="s">": "</span><span class="p">;</span>
		<span class="k">auto</span> <span class="n">cur</span><span class="o">=</span><span class="n">clock</span><span class="p">();</span>
		<span class="k">while</span><span class="p">(</span><span class="n">rnd</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">t</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
			<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">per</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
				<span class="n">t</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">per</span><span class="o">-</span><span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">cerr</span><span class="o">&lt;&lt;</span><span class="n">clock</span><span class="p">()</span><span class="o">-</span><span class="n">cur</span><span class="o">&lt;&lt;</span><span class="s">"clocks, "</span><span class="o">&lt;&lt;</span><span class="n">t</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">signed</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">ios</span><span class="o">::</span><span class="n">sync_with_stdio</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">cin</span><span class="p">.</span><span class="n">tie</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">init</span><span class="p">();</span>

	<span class="n">test_zhihu</span><span class="o">::</span><span class="n">test</span><span class="o">&lt;</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">test_zhihu</span><span class="o">::</span><span class="n">E</span><span class="o">&gt;&gt;</span><span class="p">();</span>
	<span class="n">test_zhihu</span><span class="o">::</span><span class="n">test</span><span class="o">&lt;</span><span class="n">fallocator</span><span class="o">&lt;</span><span class="n">test_zhihu</span><span class="o">::</span><span class="n">E</span><span class="o">&gt;&gt;</span><span class="p">();</span>

	<span class="n">test_stl_insertend</span><span class="o">::</span><span class="n">test</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">allocator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(),</span><span class="mi">10000</span><span class="p">);</span>
	<span class="n">test_stl_insertend</span><span class="o">::</span><span class="n">test</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">fallocator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(),</span><span class="mi">10000</span><span class="p">);</span>

	<span class="n">test_stl_insertend</span><span class="o">::</span><span class="n">test</span><span class="p">(</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">less</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span><span class="n">allocator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(),</span><span class="mi">100</span><span class="p">);</span>
	<span class="n">test_stl_insertend</span><span class="o">::</span><span class="n">test</span><span class="p">(</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">less</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span><span class="n">fallocator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(),</span><span class="mi">100</span><span class="p">);</span>

	<span class="n">test_stl_insertend</span><span class="o">::</span><span class="n">test</span><span class="o">&lt;</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">less</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span><span class="n">allocator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="mi">100000</span><span class="o">&gt;</span><span class="p">({},</span><span class="mi">1000</span><span class="p">);</span>
	<span class="n">test_stl_insertend</span><span class="o">::</span><span class="n">test</span><span class="o">&lt;</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">less</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span><span class="n">fallocator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="mi">100000</span><span class="o">&gt;</span><span class="p">({},</span><span class="mi">1000</span><span class="p">);</span>

	<span class="n">test_stl_insertend</span><span class="o">::</span><span class="n">test</span><span class="o">&lt;</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">less</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span><span class="n">allocator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="mi">10000</span><span class="o">&gt;</span><span class="p">({},</span><span class="mi">10000</span><span class="p">);</span>
	<span class="n">test_stl_insertend</span><span class="o">::</span><span class="n">test</span><span class="o">&lt;</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">less</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span><span class="n">fallocator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="mi">10000</span><span class="o">&gt;</span><span class="p">({},</span><span class="mi">10000</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>最唐诗的是，linux的自动管理体系十分超前，以至于这个allocator没有任何意义。</p>

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTgwMjQ1NjM1Niw0ODI4MTU1NTNdfQ==
-->]]></content><author><name>Orlicz</name></author><summary type="html"><![CDATA[浅谈一些科技]]></summary></entry><entry><title type="html">Daily</title><link href="//github-yet.orlicz.top/jekyll-theme-yat/2024/11/29/daily.html" rel="alternate" type="text/html" title="Daily" /><published>2024-11-29T00:00:00+00:00</published><updated>2024-11-29T00:00:00+00:00</updated><id>//github-yet.orlicz.top/jekyll-theme-yat/2024/11/29/daily</id><content type="html" xml:base="//github-yet.orlicz.top/jekyll-theme-yat/2024/11/29/daily.html"><![CDATA[<p>明天就noip了！！！</p>

<p>我介绍一些科技：</p>

<ul>
  <li>allocator。手写内存池。这个算法比较先进，O(1)分配删除 任意长度的空间。冗余大约3倍。github 上的 orlicz/advanced-allocator</li>
  <li>spj。不用testlib的。只需要cerr«“ok “就可以hydrooj判定ok了</li>
  <li>组合零点方法。</li>
</ul>

<p>$$
\prod_{i&lt;j} (x_i-x_j)^2
$$</p>

<p>这个的最高次项，关于 $(x_1,….)^{k-1}$ 的，值是 $k!(-1)^{\binom k2}$。</p>

<p>注意！这里，这个方法是说明，类似的多项式，不恒为0.（为什么?组合零点方法！）
<!--stackedit_data:
eyJoaXN0b3J5IjpbNTM4MTM3NzA3XX0=
--></p>]]></content><author><name>Orlicz</name></author><summary type="html"><![CDATA[明天就noip了！！！]]></summary></entry></feed>